#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-dir>

set -e

BUILD_DIR=$1
CACHE_DIR=$2
ENV_DIR=$3

CONFIG_FILE="$BUILD_DIR/.buildpack-config"
VENDOR_DIR="$BUILD_DIR/vendor"
JAR_DIR="$VENDOR_DIR/jars"

indent() {
  sed -u 's/^/       /'
}

echo "-----> GitHub JAR Downloader Buildpack"

# Read GITHUB_TOKEN from environment if available
if [ -d "$ENV_DIR" ] && [ -f "$ENV_DIR/GITHUB_TOKEN" ]; then
  GITHUB_TOKEN=$(cat "$ENV_DIR/GITHUB_TOKEN")
  echo "Using GitHub token for authentication" | indent
fi

# Check if config file exists
if [ ! -f "$CONFIG_FILE" ]; then
  echo "ERROR: .buildpack-config file not found!" | indent
  exit 1
fi

# Parse configuration
echo "-----> Reading configuration from .buildpack-config"
source "$CONFIG_FILE"

# Validate required configuration
if [ -z "$GITHUB_REPO_OWNER" ] || [ -z "$GITHUB_REPO_NAME" ]; then
  echo "ERROR: GITHUB_REPO_OWNER and GITHUB_REPO_NAME must be set in .buildpack-config" | indent
  exit 1
fi

if [ -z "$JAR_FILENAME" ]; then
  echo "ERROR: JAR_FILENAME must be set in .buildpack-config" | indent
  exit 1
fi

# Set default release tag to 'latest' if not specified
RELEASE_TAG=${RELEASE_TAG:-"latest"}

echo "Repository: $GITHUB_REPO_OWNER/$GITHUB_REPO_NAME" | indent
echo "Release Tag: $RELEASE_TAG" | indent
echo "JAR Filename: $JAR_FILENAME" | indent

# Create vendor directory
mkdir -p "$JAR_DIR"

# Prepare authentication headers if token is available
if [ -n "$GITHUB_TOKEN" ]; then
  AUTH_HEADER="Authorization: token $GITHUB_TOKEN"
  CURL_AUTH="-H \"$AUTH_HEADER\""
else
  CURL_AUTH=""
fi

# Determine download URL and asset ID
if [ "$RELEASE_TAG" == "latest" ]; then
  echo "-----> Fetching latest release information"
  API_URL="https://api.github.com/repos/$GITHUB_REPO_OWNER/$GITHUB_REPO_NAME/releases/latest"

  # Get release info with authentication if available
  if [ -n "$GITHUB_TOKEN" ]; then
    RELEASE_INFO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$API_URL")
  else
    RELEASE_INFO=$(curl -s "$API_URL")
  fi

  ACTUAL_TAG=$(echo "$RELEASE_INFO" | grep '"tag_name"' | sed -E 's/.*"tag_name": "([^"]+)".*/\1/')
  echo "Latest release tag: $ACTUAL_TAG" | indent
else
  echo "-----> Fetching release information for tag: $RELEASE_TAG"
  API_URL="https://api.github.com/repos/$GITHUB_REPO_OWNER/$GITHUB_REPO_NAME/releases/tags/$RELEASE_TAG"

  # Get release info with authentication if available
  if [ -n "$GITHUB_TOKEN" ]; then
    RELEASE_INFO=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$API_URL")
  else
    RELEASE_INFO=$(curl -s "$API_URL")
  fi

  ACTUAL_TAG="$RELEASE_TAG"
fi

# Check if we got valid release info
if echo "$RELEASE_INFO" | grep -q '"message": "Not Found"'; then
  echo "ERROR: Release not found. Please check your GITHUB_TOKEN has access to the repository." | indent
  exit 1
fi

# Extract asset information for the JAR file
# Need to find the asset ID which comes before the name in the JSON
# Use a more robust method to parse the JSON

# First check if the JAR file exists in the release
if ! echo "$RELEASE_INFO" | grep -q "\"name\": \"$JAR_FILENAME\""; then
  echo "ERROR: Could not find JAR file '$JAR_FILENAME' in release" | indent
  echo "Available assets:" | indent
  echo "$RELEASE_INFO" | grep '"name":' | sed 's/.*"name": "\([^"]*\)".*/\1/' | indent
  exit 1
fi

# Extract the asset ID - the id field comes before the name field in each asset object
# We'll use a more robust approach: find all assets and match by name
ASSET_ID=$(echo "$RELEASE_INFO" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    assets = data.get('assets', [])
    for asset in assets:
        if asset.get('name') == '$JAR_FILENAME':
            print(asset.get('id', ''))
            break
except:
    pass
")

# Fallback to grep/sed if python parsing fails
if [ -z "$ASSET_ID" ]; then
  echo "Trying alternative parsing method..." | indent
  # Split on assets, find the one with our filename, extract its ID
  ASSET_ID=$(echo "$RELEASE_INFO" | awk '
    /"id":/ { id = $0; gsub(/[^0-9]/, "", id) }
    /"name": "'"$JAR_FILENAME"'"/ { print id; exit }
  ')
fi

if [ -z "$ASSET_ID" ]; then
  echo "ERROR: Could not extract asset ID for '$JAR_FILENAME'" | indent
  echo "Available assets:" | indent
  echo "$RELEASE_INFO" | grep '"name":' | sed 's/.*"name": "\([^"]*\)".*/\1/' | indent
  exit 1
fi

# For private repos, we need to use the API endpoint with Accept header
# For public repos, the direct URL works, but API endpoint works for both
DOWNLOAD_URL="https://api.github.com/repos/$GITHUB_REPO_OWNER/$GITHUB_REPO_NAME/releases/assets/$ASSET_ID"

echo "Asset ID: $ASSET_ID" | indent

# Check cache
CACHE_FILE="$CACHE_DIR/$JAR_FILENAME"
CACHE_TAG_FILE="$CACHE_DIR/release_tag"

if [ -f "$CACHE_FILE" ] && [ -f "$CACHE_TAG_FILE" ]; then
  CACHED_TAG=$(cat "$CACHE_TAG_FILE")
  if [ "$RELEASE_TAG" == "latest" ]; then
    COMPARE_TAG="$ACTUAL_TAG"
  else
    COMPARE_TAG="$RELEASE_TAG"
  fi

  if [ "$CACHED_TAG" == "$COMPARE_TAG" ]; then
    echo "-----> Using cached JAR file" | indent
    cp "$CACHE_FILE" "$JAR_DIR/$JAR_FILENAME"
    echo "Copied from cache" | indent
  else
    echo "-----> Cache invalidated (tag changed: $CACHED_TAG -> $COMPARE_TAG)" | indent
    DOWNLOAD_JAR=true
  fi
else
  DOWNLOAD_JAR=true
fi

# Download JAR if needed
if [ "$DOWNLOAD_JAR" == "true" ]; then
  echo "-----> Downloading JAR file"

  # Download using GitHub API (works for both public and private repos)
  # The Accept header tells GitHub to return the asset binary instead of JSON
  if [ -n "$GITHUB_TOKEN" ]; then
    curl -L -f \
      -H "Authorization: token $GITHUB_TOKEN" \
      -H "Accept: application/octet-stream" \
      -o "$JAR_DIR/$JAR_FILENAME" \
      "$DOWNLOAD_URL"
  else
    curl -L -f \
      -H "Accept: application/octet-stream" \
      -o "$JAR_DIR/$JAR_FILENAME" \
      "$DOWNLOAD_URL"
  fi

  if [ $? -eq 0 ]; then
    echo "Downloaded successfully" | indent

    # Update cache
    mkdir -p "$CACHE_DIR"
    cp "$JAR_DIR/$JAR_FILENAME" "$CACHE_FILE"
    if [ "$RELEASE_TAG" == "latest" ]; then
      echo "$ACTUAL_TAG" > "$CACHE_TAG_FILE"
    else
      echo "$RELEASE_TAG" > "$CACHE_TAG_FILE"
    fi
    echo "Cached for future builds" | indent
  else
    echo "ERROR: Failed to download JAR file from $DOWNLOAD_URL" | indent
    exit 1
  fi
fi

# Verify the JAR file
if [ -f "$JAR_DIR/$JAR_FILENAME" ]; then
  JAR_SIZE=$(du -h "$JAR_DIR/$JAR_FILENAME" | cut -f1)
  echo "-----> JAR file ready: $JAR_FILENAME ($JAR_SIZE)" | indent
else
  echo "ERROR: JAR file not found after download" | indent
  exit 1
fi

# Create profile.d script to add JAR to classpath and optionally start it
PROFILE_DIR="$BUILD_DIR/.profile.d"
mkdir -p "$PROFILE_DIR"

# Set default for AUTO_START if not specified
AUTO_START=${AUTO_START:-"false"}

if [ "$AUTO_START" == "true" ]; then
  echo "-----> JAR will auto-start as background process at runtime" | indent
  
  cat > "$PROFILE_DIR/github-jar-loader.sh" <<EOF
# Add downloaded JAR to classpath
export CLASSPATH="\$HOME/vendor/jars/*:\$CLASSPATH"

# Start JAR in background if not already running
if [ ! -f /tmp/github-jar.pid ] || ! ps -p \$(cat /tmp/github-jar.pid 2>/dev/null) > /dev/null 2>&1; then
  echo "Starting background JAR: $JAR_FILENAME"
  nohup java $JVM_OPTIONS -jar "\$HOME/vendor/jars/$JAR_FILENAME" > "\$HOME/logs/github-jar.log" 2>&1 &
  echo \$! > /tmp/github-jar.pid
  echo "Background JAR started with PID \$(cat /tmp/github-jar.pid)"
else
  echo "Background JAR already running with PID \$(cat /tmp/github-jar.pid)"
fi
EOF

  # Create logs directory
  mkdir -p "$BUILD_DIR/logs"
  
  echo "JAR will start automatically in background" | indent
  echo "Logs: \$HOME/logs/github-jar.log" | indent
  echo "PID file: /tmp/github-jar.pid" | indent
else
  cat > "$PROFILE_DIR/github-jar-loader.sh" <<'EOF'
# Add downloaded JAR to classpath
export CLASSPATH="$HOME/vendor/jars/*:$CLASSPATH"
EOF
  
  echo "-----> JAR will be available in classpath at runtime" | indent
fi

echo "Location: \$HOME/vendor/jars/$JAR_FILENAME" | indent

echo "-----> Build complete!"

